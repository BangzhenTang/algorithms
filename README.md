# algorithms
整理面试过程中的常见算法题，都是可以实际运行的，算是积累一下，让自己的算法功力厚积薄发吧！</br>
注意：</br>
1.面试过程中算法题99%都是手写，所以既要弄清原理，又要可以代码实现，还要锻炼在无编译运行环境下手写算法的能力。</br>
2.面试时的算法实现语言多种多样，但是万变不离其宗，所以在这里我们采用的是基础语言C来编写算法。</br>
3.还没想好，想好再加。

# 算法题
## 1.FizzBuzz问题
### 描述
>写一个程序打印1到100这些数字。但是遇到数字为3的倍数的时候，打印“Fizz”替代数字，5的倍数用“Buzz”代替，既是3的倍数又是5的倍数打印“FizzBuzz”。
### 分析
这是一个入门级的笔试题，用来考察应试者的基本编码能力和逻辑能力，如果这道题写了5分钟以上或者答不出来的话，那就需要考虑一下自己是否是一个合格的coder了。
### 算法实现
[FizzBuzz.c](https://github.com/Ray1024/algorithms/blob/master/FizzBuzz.c)

## 2.查找算法——线性查找
### 描述
>在一个数组中查找指定数值。
### 分析
顺序查找也称为线形查找，属于无序查找算法。遍历整个数组和指定数值比较，若相等则表示查找成功；若便利完成还没有找到相等的，表示查找失败。
### 复杂度
O(N)
### 算法实现
[SearchSequence.c](https://github.com/Ray1024/algorithms/blob/master/SearchSequence.c)

## 3.查找算法——二分查找（折半查找）
### 描述
>在一个数组中查找指定数值。
### 分析
首先要求该组元素必须是有序的，假设默认是从小到大排列，使用该组元素的中间元素与目标元素进行比较，如果相等则查找成功，如果中间元素比目标元素小，则去中间元素的右侧查找（递归），如果中间元素比目标元素大，则去中间元素的左侧查找（递归），直到找到目标元素 或者比较完毕，表示查找失败。
### 复杂度
O(logN)
### 算法实现
[SearchBinary.c](https://github.com/Ray1024/algorithms/blob/master/SearchBinary.c)

## 4.排序算法——冒泡排序
### 描述
>将一个数组中的元素排序。
### 分析
如：
同学甲 同学乙（比身高） 同一个水平线上 背靠背</br>
（1）算法流程</br>
a.比较相邻位置的元素，如果左边的比右边的大，则交换两个元素的位置</br>
b.针对每一对相邻位置的元素都重复上一步，从第一对到最后一对比较完毕，经过这一步，最后的元素就是这组元素中的最大值</br>
c.针对所有元素重复以上步骤，直到没有可以交换的元素为止
### 复杂度
平均时间复杂度 O(N^2)，稳定，对样本的有序性比较敏感
### 算法实现
[SortBubble.c](https://github.com/Ray1024/algorithms/blob/master/SortBubble.c)

## 5.排序算法——插入排序
### 描述
>将一个数组中的元素排序。
### 分析
a.从第一个元素起，假定该元素已经有序</br>
b.从第二个元素起，依次取出元素，与左边已经有序的元素一次进行比较</br>
c.如果左边的元素大于取出的元素，则将左边的元素右移，让取出的元素继续与左边比较</br>
d.如果左边的元素小于取出的元素，则将取出的元素插入到左边元素的右边</br>
e.重复以上过程，直到处理完所有的元素
### 复杂度
平均时间复杂度 O(N^2)，稳定，对样本的有序性比较敏感，但是赋值的次数比冒泡排序少，因此一般情况略优于冒泡排序
### 算法实现
[SortInsert.c](https://github.com/Ray1024/algorithms/blob/master/SortInsert.c)

## 6.排序算法——选择排序
### 描述
>将一个数组中的元素排序。
### 分析
a.从第一个元素起一次取出，假定取出的元素为最小值，并且记录下标</br>
b.使用记录的最小值与后续元素进行比较，如果后续的元素中有比记录的最小值还小的元素，则重新记录下标，也就是后续元素变成了记录的最小值</br>
c.直到记录的最小值与后续所有元素比较完毕，交换记录的最小值和一开始假定的最小值</br>
d.重复上述过程，直到所有元素处理完毕
### 复杂度
平均时间复杂度 O(N^2)，不稳定，对样本的有序性不敏感，比较的次数比较多，交换的次数比较少，因此一般情况下略优于冒泡排序
### 算法实现
[SortChoose.c](https://github.com/Ray1024/algorithms/blob/master/SortChoose.c)

## 7.n层汉诺塔问题
### 描述
>有A,B,C三根柱子，将A上N个从小到大叠放的盘子移动到C，一次只能移动一个，不重复移动，小盘子必须在大盘子上面。</br>
>实现整个过程，并且求出n个盘子时需要的移动次数。
### 分析
这是一个经典的递归问题，主要思想在于分解整体过程。</br>
整个过程以“移动最大盘子”为中央，被分为了两部分。即（前）“将那坨N-1个盘子从A移动到B”，(中)“移动最大盘子”，(后)“将坨N-1个盘子从B移动到C”。</br>
这是我们意识到，（前）与（后）操作道理是相似的。不去管那个最大盘子，（前）是以C针为中转站，（后）是以A针为中转站。因此两者所需的移动次数应当是相等的。这意味着我们只要计算出其中一者的移动次数，然而乘以2，在加上“移动最大盘子”的那1次，就是这场游戏的总移动次数了。用数学语言表达，假设（前）“将N-1个盘子从A针移动到B针”所需次数为Hn-1，总移动次数为Hn，那么可以得出的关系就是：Hn=Hn-1x 2 + 1。</br>
于是Hn=Hn-1 x 2 + 1 这个公式，就可以套用、套用、套用……直到H3=7，H2=3，H1=1。</br>
最后，用数学归纳法证明通项公式Hn = 2^n-1。

### 参考链接
如何理解汉诺塔的递归？ - YIHE陳的回答 - 知乎
https://www.zhihu.com/question/24385418/answer/46241635

### 算法实现
[Hanoi.c](https://github.com/Ray1024/algorithms/blob/master/Hanoi.c)
